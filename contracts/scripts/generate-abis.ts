#!/usr/bin/env tsx

import { readFileSync, mkdirSync, writeFileSync } from "fs";
import { join } from "path";

/**
 * Post-build script to automatically generate TypeScript ABI exports
 * from Foundry compilation artifacts
 */

interface ContractArtifact {
  abi: any[];
}

interface ABIExport {
  name: string;
  contractName: string;
  exportName: string;
}

// Contracts to generate ABIs for
const CONTRACTS: ABIExport[] = [
  {
    name: "PoolFactory",
    contractName: "PoolFactory",
    exportName: "PoolFactoryABI",
  },
  {
    name: "Pool",
    contractName: "Pool",
    exportName: "PoolABI",
  },
];

/**
 * Load contract artifact and extract ABI
 */
function loadContractABI(contractName: string): any[] {
  const artifactPath = join(
    process.cwd(),
    "out",
    `${contractName}.sol`,
    `${contractName}.json`,
  );

  try {
    const artifact: ContractArtifact = JSON.parse(
      readFileSync(artifactPath, "utf8"),
    );
    return artifact.abi;
  } catch (error) {
    throw new Error(`Failed to load artifact for ${contractName}: ${error}`);
  }
}

/**
 * Generate TypeScript ABI export string
 */
function generateABIExport(exportName: string, abi: any[]): string {
  const abiString = JSON.stringify(abi, null, 2);
  return `export const ${exportName} = ${abiString} as const;`;
}

/**
 * Generate the complete index.ts file content
 */
function generateIndexFile(): string {
  const header = `/**
 * Auto-generated ABI exports for smart contracts
 * Generated from forge artifacts at ${new Date().toISOString()}
 * 
 * DO NOT EDIT MANUALLY - This file is automatically generated by scripts/generate-abis.ts
 * Run \`npm run build\` to regenerate this file
 */

`;

  const exports: string[] = [];

  for (const contract of CONTRACTS) {
    try {
      console.log(`üìÑ Loading ABI for ${contract.contractName}...`);
      const abi = loadContractABI(contract.contractName);
      const exportString = generateABIExport(contract.exportName, abi);
      exports.push(exportString);
      console.log(
        `‚úÖ Generated ${contract.exportName} with ${abi.length} entries`,
      );
    } catch (error) {
      console.error(`‚ùå Failed to process ${contract.contractName}:`, error);
      throw error;
    }
  }

  return header + exports.join("\n\n") + "\n";
}

/**
 * Main function
 */
async function main() {
  console.log("üî® Generating ABI exports...");

  try {
    // Generate the complete index.ts content
    const indexContent = generateIndexFile();

    // Ensure abi folder exists
    const abiDir = join(process.cwd(), "abi");
    try {
      mkdirSync(abiDir, { recursive: true });
    } catch (err) {
      // Ignore if already exists
    }

    // Write to abi/index.ts
    const outputPath = join(abiDir, "index.ts");
    writeFileSync(outputPath, indexContent, "utf8");

    console.log(`‚úÖ Successfully generated ABI exports at ${outputPath}`);
    console.log(`üìä Generated exports for ${CONTRACTS.length} contracts:`);
    CONTRACTS.forEach((contract) => {
      console.log(`   - ${contract.exportName}`);
    });
  } catch (error) {
    console.error("‚ùå Failed to generate ABI exports:", error);
    process.exit(1);
  }
}

// Handle errors
function handleError(error: unknown): never {
  console.error("‚ùå Script failed:", error);
  process.exit(1);
}

main().catch(handleError);
